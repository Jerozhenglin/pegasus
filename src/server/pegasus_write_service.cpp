// Copyright (c) 2017, Xiaomi, Inc.  All rights reserved.
// This source code is licensed under the Apache License Version 2.0, which
// can be found in the LICENSE file in the root directory of this source tree.

#include "pegasus_write_service.h"
#include "pegasus_server_impl.h"
#include "rocksdb_logging.h"

#include "base/pegasus_key_schema.h"

namespace pegasus {
namespace server {

static inline dsn::blob composite_raw_key(dsn::string_view hash_key, dsn::string_view sort_key)
{
    dsn::blob raw_key;
    pegasus_generate_key(raw_key, hash_key, sort_key);
    return raw_key;
}

class pegasus_write_service::impl
{
public:
    explicit impl(pegasus_server_impl *server)
        : _server(server),
          _gpid(server->_gpid),
          _verbose_log(server->_verbose_log),
          _primary_address(server->_primary_address),
          _value_schema_version(server->_value_schema_version),
          _db(server->_db),
          _wt_opts(&server->_wt_opts),
          _rd_opts(&server->_rd_opts)
    {
    }

    void multi_put(const db_write_context &ctx,
                   const dsn::apps::multi_put_request &update,
                   dsn::apps::update_response &resp)
    {
        resp.app_id = _gpid.get_app_id();
        resp.partition_index = _gpid.get_partition_index();
        resp.decree = ctx.decree;
        resp.server = _primary_address;

        if (update.kvs.empty()) {
            // invalid argument
            derror("%s: invalid argument for multi_put: decree = %" PRId64 ", error = empty kvs",
                   replica_name(),
                   ctx.decree);

            // an invalid operation shouldn't be added to latency calculation TODO(wutao1): why?
            resp.error = rocksdb::Status::kInvalidArgument;
            return;
        }

        for (auto &kv : update.kvs) {
            db_write_batch_put(composite_raw_key(update.hash_key, kv.key),
                               kv.value,
                               static_cast<uint32_t>(update.expire_ts_seconds),
                               ctx);
        }

        resp.error = db_write(ctx.decree);
    }

    void multi_remove(const db_write_context &ctx,
                      const dsn::apps::multi_remove_request &update,
                      dsn::apps::multi_remove_response &resp)
    {
        resp.app_id = _gpid.get_app_id();
        resp.partition_index = _gpid.get_partition_index();
        resp.decree = ctx.decree;
        resp.server = _primary_address;

        if (update.sort_keys.empty()) {
            // invalid argument
            derror("%s: invalid argument for multi_remove: decree = %" PRId64
                   ", error = empty sort keys",
                   replica_name(),
                   ctx.decree);

            // an invalid operation shoundn't be added to latency calculation
            resp.error = rocksdb::Status::kInvalidArgument;
            resp.count = 0;
            return;
        }

        for (auto &sort_key : update.sort_keys) {
            db_write_batch_delete(composite_raw_key(update.hash_key, sort_key), ctx);
        }

        resp.error = db_write(ctx.decree);
        if (resp.error != 0) {
            resp.count = 0;
        } else {
            resp.count = update.sort_keys.size();
        }
    }

    int batch_commit(int64_t decree, dsn::apps::update_response &resp)
    {
        resp.error = db_write(decree);
        resp.app_id = _gpid.get_app_id();
        resp.partition_index = _gpid.get_partition_index();
        resp.decree = decree;
        resp.server = _primary_address;

        _batch.Clear();
        return resp.error;
    }

public:
    // Each of the duplicated update has a timetag (call it `remote_timetag`) that's used
    // to keep consistency between remote cluster and local cluster.
    // Before applying the update, if the record on storage has a larger timetag than
    // the `remote_timetag`, the request will be ignored, otherwise it will be applied
    // using the *new* timetag generated by local cluster.

    void db_write_batch_put(dsn::string_view raw_key,
                            dsn::string_view value,
                            uint32_t expire_sec,
                            const db_write_context &ctx)
    {
        if (ctx.remote_timetag > 0) {
            std::string raw_value;
            rocksdb::Status s = _db->Get(*_rd_opts, to_rocksdb_slice(raw_key), &raw_value);
            if (s.ok()) {
                uint64_t local_timetag = pegasus_extract_timetag(_value_schema_version, raw_value);
                if (local_timetag > ctx.remote_timetag) {
                    // ignore if the duplicated value is stale
                    return;
                }
            } else if (s.code() != rocksdb::Status::kNotFound) {
                derror_rocksdb("get",
                               s.ToString(),
                               "remote_timetag({}), raw_key(len: {}, data: {})",
                               ctx.remote_timetag,
                               raw_key.length(),
                               raw_key.data());
                return;
            }
        }

        rocksdb::Slice skey = to_rocksdb_slice(raw_key);
        rocksdb::SliceParts skey_parts(&skey, 1);
        rocksdb::SliceParts svalue =
            _value_generator.generate_value(_value_schema_version, value, expire_sec, ctx.timetag);
        _batch.Put(skey_parts, svalue);
    }

    void db_write_batch_delete(dsn::string_view raw_key, const db_write_context &ctx)
    {
        _batch.Delete(to_rocksdb_slice(raw_key));
    }

    // Apply the write batch in to rocksdb.
    int db_write(int64_t decree)
    {
        _wt_opts->given_decree = static_cast<uint64_t>(decree);
        auto status = _db->Write(*_wt_opts, &_batch);
        if (!status.ok()) {
            derror_rocksdb("write", status.ToString(), "decree: {}", decree);
        }
        return status.code();
    }

    const char *replica_name() const { return _server->replica_name(); }

private:
    pegasus_server_impl *_server;

    const dsn::gpid _gpid;
    const bool _verbose_log;
    const std::string _primary_address;
    const int _value_schema_version;

    rocksdb::WriteBatch _batch;
    rocksdb::DB *_db;
    rocksdb::WriteOptions *_wt_opts;
    const rocksdb::ReadOptions *_rd_opts;

    pegasus_value_generator _value_generator;
};

pegasus_write_service::pegasus_write_service(pegasus_server_impl *server)
    : _impl(new impl(server)), _batch_start_time(0)
{
    std::string str_gpid =
        fmt::format("{}.{}", server->_gpid.get_app_id(), server->_gpid.get_partition_index());

    std::string name;

    name = fmt::format("put_qps@{}", str_gpid);
    _pfc_put_qps.init_app_counter(
        "app.pegasus", name.c_str(), COUNTER_TYPE_RATE, "statistic the qps of PUT request");

    name = fmt::format("multi_put_qps@{}", str_gpid);
    _pfc_multi_put_qps.init_app_counter(
        "app.pegasus", name.c_str(), COUNTER_TYPE_RATE, "statistic the qps of MULTI_PUT request");

    name = fmt::format("remove_qps@{}", str_gpid);
    _pfc_remove_qps.init_app_counter(
        "app.pegasus", name.c_str(), COUNTER_TYPE_RATE, "statistic the qps of REMOVE request");

    name = fmt::format("multi_remove_qps@{}", str_gpid);
    _pfc_multi_remove_qps.init_app_counter("app.pegasus",
                                           name.c_str(),
                                           COUNTER_TYPE_RATE,
                                           "statistic the qps of MULTI_REMOVE request");

    name = fmt::format("put_latency@{}", str_gpid);
    _pfc_put_latency.init_app_counter("app.pegasus",
                                      name.c_str(),
                                      COUNTER_TYPE_NUMBER_PERCENTILES,
                                      "statistic the latency of PUT request");

    name = fmt::format("multi_put_latency@{}", str_gpid);
    _pfc_multi_put_latency.init_app_counter("app.pegasus",
                                            name.c_str(),
                                            COUNTER_TYPE_NUMBER_PERCENTILES,
                                            "statistic the latency of MULTI_PUT request");

    name = fmt::format("remove_latency@{}", str_gpid);
    _pfc_remove_latency.init_app_counter("app.pegasus",
                                         name.c_str(),
                                         COUNTER_TYPE_NUMBER_PERCENTILES,
                                         "statistic the latency of REMOVE request");

    name = fmt::format("multi_remove_latency@{}", str_gpid);
    _pfc_multi_remove_latency.init_app_counter("app.pegasus",
                                               name.c_str(),
                                               COUNTER_TYPE_NUMBER_PERCENTILES,
                                               "statistic the latency of MULTI_REMOVE request");
}

pegasus_write_service::~pegasus_write_service() {}

int pegasus_write_service::multi_put(const db_write_context &ctx,
                                     const dsn::apps::multi_put_request &update,
                                     dsn::apps::update_response &resp)
{
    uint64_t start_time = dsn_now_ns();
    _pfc_multi_put_qps->increment();
    _impl->multi_put(ctx, update, resp);
    _pfc_multi_put_latency->set(dsn_now_ns() - start_time);
    return resp.error;
}

int pegasus_write_service::multi_remove(const db_write_context &ctx,
                                        const dsn::apps::multi_remove_request &update,
                                        dsn::apps::multi_remove_response &resp)
{
    uint64_t start_time = dsn_now_ns();
    _pfc_multi_remove_qps->increment();
    _impl->multi_remove(ctx, update, resp);
    _pfc_multi_remove_latency->set(dsn_now_ns() - start_time);
    return resp.error;
}

void pegasus_write_service::batch_put(const db_write_context &ctx,
                                      const dsn::apps::update_request &update)
{
    _pfc_put_qps->increment();
    _batch_perfcounters.push_back(_pfc_put_latency.get());

    _impl->db_write_batch_put(
        update.key, update.value, static_cast<uint32_t>(update.expire_ts_seconds), ctx);
}

void pegasus_write_service::batch_remove(const db_write_context &ctx, const dsn::blob &key)
{
    _pfc_remove_qps->increment();
    _batch_perfcounters.push_back(_pfc_remove_latency.get());

    _impl->db_write_batch_delete(key, ctx);
}

int pegasus_write_service::batch_commit(int64_t decree, dsn::apps::update_response &resp)
{
    dassert(_batch_start_time != 0, "batch_commit and batch_prepare must be called in pair");

    int ret = _impl->batch_commit(decree, resp);

    uint64_t latency = dsn_now_ns() - _batch_start_time;
    for (dsn::perf_counter *pfc : _batch_perfcounters) {
        pfc->set(latency);
    }

    _batch_perfcounters.clear();
    _batch_start_time = 0;

    return ret;
}

void pegasus_write_service::batch_prepare()
{
    dassert(_batch_start_time == 0, "batch_commit and batch_prepare must be called in pair");

    _batch_start_time = dsn_now_ns();
}

int pegasus_write_service::empty_put(const db_write_context &ctx)
{
    std::string empty_key, empty_value;
    _impl->db_write_batch_put(empty_key, empty_value, 0, ctx);
    return _impl->db_write(ctx.decree);
}

} // namespace server
} // namespace pegasus
